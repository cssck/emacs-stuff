;;; denote-sequence-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))



;;; Generated autoloads from denote-sequence.el

(autoload 'denote-sequence "denote-sequence" "\
Create a new sequence note of TYPE among `denote-sequence-types'.
If TYPE is either `child' or `sibling', then it is an extension of
FILE-WITH-SEQUENCE.

When called interactively, prompt for TYPE and, when necessary, for
FILE-WITH-SEQUENCE whose sequence will be used to derive a new sequence.
Files available at the minibuffer prompt are those returned by
`denote-sequence-get-all-files'.

(fn TYPE &optional FILE-WITH-SEQUENCE)" t)
(autoload 'denote-sequence-new-parent "denote-sequence" "\
Like `denote-sequence' to directly create new parent." t)
(autoload 'denote-sequence-new-sibling "denote-sequence" "\
Like `denote-sequence' to directly create new sibling of SEQUENCE.
When called interactively, SEQUENCE is a file among files in the variable
`denote-directory' that have a sequence (per `denote-sequence-file-p').

When called from Lisp, SEQUENCE is a string that conforms with
`denote-sequence-p'.

(fn SEQUENCE)" t)
(autoload 'denote-sequence-new-sibling-of-current "denote-sequence" "\
Create a new sibling sequence of the current file with SEQUENCE.
If the current file does not have a sequence, then behave exactly like
`denote-sequence-new-sibling'.

(fn SEQUENCE)" t)
(autoload 'denote-sequence-new-child "denote-sequence" "\
Like `denote-sequence' to directly create new child of SEQUENCE.
When called interactively, SEQUENCE is a file among files in the variable
`denote-directory' that have a sequence (per `denote-sequence-file-p').

When called from Lisp, SEQUENCE is a string that conforms with
`denote-sequence-p'.

(fn SEQUENCE)" t)
(autoload 'denote-sequence-new-child-of-current "denote-sequence" "\
Create a new child sequence of the current file with SEQUENCE.
If the current file does not have a sequence, then behave exactly like
`denote-sequence-new-child'.

(fn SEQUENCE)" t)
(autoload 'denote-sequence-find "denote-sequence" "\
Find all relatives of the given TYPE using the current file's sequence.
Prompt for TYPE among `denote-sequence-relative-types' and then prompt
for a file among the matching files.

(fn TYPE)" t)
(autoload 'denote-sequence-link "denote-sequence" "\
Link to FILE with sequence.
This is like the `denote-link' command but only accepts to link to a
file that conforms with `denote-sequence-file-p'.  When called
interactively, only relevant files are shown for minibuffer completion
from the variable `denote-directory'.

Optional ID-ONLY has the same meaning as the `denote-link' command.

(fn FILE &optional ID-ONLY)" t)
(autoload 'denote-sequence-dired "denote-sequence" "\
Produce a Dired listing of all sequence notes.
Sort sequences from smallest to largest.

With optional PREFIX string, show only files whose sequence matches it.

With optional DEPTH as a number, limit the list to files whose sequence
is that many levels deep.  For example, 1=1=2 is three levels deep.

For a more specialised case, see `denote-sequence-find-relatives-dired'.

(fn &optional PREFIX DEPTH)" t)
(autoload 'denote-sequence-find-dired "denote-sequence" "\
Like `denote-sequence-find' for TYPE but put the matching files in Dired.
Also see `denote-sequence-dired'.

(fn TYPE)" t)
(autoload 'denote-sequence-reparent "denote-sequence" "\
Re-parent the CURRENT-FILE to be a child of FILE-WITH-SEQUENCE.
If CURRENT-FILE has a sequence (the Denote file name signature), change
it.  Else create a new one.

When called interactively, CURRENT-FILE is either the current file, or a
special Org buffer (like those of `org-capture'), or the file at point in
Dired.

When called interactively, prompt for FILE-WITH-SEQUENCE showing only
the files in the variable `denote-directory' which have a sequence.  If
no such files exist, throw an error.

When called from Lisp, CURRENT-FILE is a string pointing to a file.

When called from Lisp, FILE-WITH-SEQUENCE is either a file with a
sequence (per `denote-sequence-file-p') or the sequence string as
such (per `denote-sequence-p').  In both cases, what matters is to know
the target sequence.

(fn CURRENT-FILE FILE-WITH-SEQUENCE)" t)
(autoload 'denote-sequence-convert "denote-sequence" "\
Convert the sequence scheme of FILES to match `denote-sequence-scheme'.
When called from inside a Denote file, FILES is just the current file.
When called from a Dired buffer, FILES are the marked files.  If no
files are marked, then the one at point is considered.

Do not make any changes if the file among the FILES has no sequence or
if it already matches the value of `denote-sequence-scheme'.  A file has
a sequence when it conforms with `denote-sequence-file-p'.

This command is for users who once used a `denote-sequence-scheme' and
have since decided to switch to another.  IT DOES NOT REPARENT OR ANYHOW
CHECK THE RESULTING SEQUENCES FOR DUPLICATES.

(fn FILES)" '(dired-mode))
(register-definition-prefixes "denote-sequence" '("denote-sequence-"))

;;; End of scraped data

(provide 'denote-sequence-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; denote-sequence-autoloads.el ends here
